<?php
namespace App\Services;

use App\Support\CommandRunner;
use DirectoryIterator;
use RuntimeException;

class NginxConfigService
{
    private string $sitesEnabledDir;
    private string $sitesDisabledDir;
    private string $websitesRoot;
    private string $nginxBinary;
    private string $templatePath;
    private ?string $templateSourcePath;
    private array $defaults;
    private array $allowedCommands;
    private NginxConfigParser $parser;
    private CommandRunner $commandRunner;

    public function __construct(array $paths, array $defaults = [], array $allowedCommands = [], ?CommandRunner $commandRunner = null)
    {
        $this->sitesEnabledDir = rtrim($paths['nginx_sites_enabled'], '/');
        $this->sitesDisabledDir = rtrim($paths['nginx_disabled_dir'], '/');
        $this->websitesRoot = rtrim($paths['websites_root'], '/');
        $this->nginxBinary = $paths['nginx_binary'];
        $this->templatePath = __DIR__ . '/../../templates/nginx_site.conf.php';
        $this->templateSourcePath = $paths['nginx_template_source'] ?? null;
        $this->defaults = $this->resolveDefaults($defaults);
        $this->allowedCommands = $allowedCommands;
        $this->parser = new NginxConfigParser();
        $this->commandRunner = $commandRunner ?? new CommandRunner();

        if (!is_dir($this->sitesDisabledDir)) {
            @mkdir($this->sitesDisabledDir, 0755, true);
        }
    }

    public function listSites(): array
    {
        $sites = array_merge(
            $this->scanDirectory($this->sitesEnabledDir, true),
            $this->scanDirectory($this->sitesDisabledDir, false)
        );
        usort($sites, fn ($a, $b) => strcmp($a['server_name'], $b['server_name']));
        return $sites;
    }

    private function scanDirectory(string $path, bool $enabled): array
    {
        if (!is_dir($path)) {
            return [];
        }

        $sites = [];
        foreach (new DirectoryIterator($path) as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }

            if (!$fileInfo->isFile() && !$fileInfo->isLink()) {
                continue;
            }

            $filename = $fileInfo->getFilename();

            if (preg_match('/~$/', $filename)) {
                continue;
            }

            $sites[] = $this->parseSiteConfig($fileInfo->getPathname(), $enabled);
        }

        return $sites;
    }

    private function parseSiteConfig(string $file, bool $enabled): array
    {
        $content = file_get_contents($file) ?: '';
        $parsed = $this->parser->parse($content);

        $serverName = $parsed['server_name'] ?? $this->deriveNameFromPath($file);
        $listen = $parsed['listen'] ?: ['80'];
        $serverNames = $parsed['server_names'] ?? [$serverName];

        return [
            'server_name' => $serverName,
            'server_names' => $serverNames,
            'aliases' => array_slice($serverNames, 1),
            'root' => $parsed['root'] ?? $this->websitesRoot,
            'listen' => implode(', ', $listen),
            'listen_directives' => $listen,
            'php_fastcgi' => $parsed['fastcgi_pass'] ?? null,
            'index' => $parsed['index'] ?? null,
            'ssl' => $parsed['ssl'] ?? false,
            'ssl_certificate' => $parsed['ssl_certificate'] ?? null,
            'ssl_certificate_key' => $parsed['ssl_certificate_key'] ?? null,
            'ssl_includes' => $parsed['ssl_includes'] ?? [],
            'enabled' => $enabled,
            'path' => $file,
            'raw' => $content,
            'managed' => $this->isManagedConfig($content),
        ];
    }

    private function deriveNameFromPath(string $path): string
    {
        $basename = basename($path);
        return preg_replace('/\.[^.]+$/', '', $basename) ?? $basename;
    }

    private function isManagedConfig(string $content): bool
    {
        return str_contains($content, 'Generated by webadmin panel')
            || str_contains($content, 'Managed by webadmin');
    }

    public function createSite(array $data): array
    {
        $serverName = $this->normalizeServerName($data['server_name']);
        $https = (bool) ($data['https'] ?? false);

        $blueprint = $this->buildBlueprint($serverName, $https);
        $this->validateRoot($blueprint['root']);

        $configPath = $this->sitesEnabledDir . '/' . $this->sanitizeName($serverName) . '.conf';

        if (file_exists($configPath)) {
            throw new RuntimeException('Configuration already exists for ' . $serverName);
        }

        $this->writeConfig($configPath, $blueprint);
        $this->ensureSiteRoot($blueprint['root']);
        $this->testConfig();

        return $this->parseSiteConfig($configPath, true);
    }

    public function toggleSite(string $serverName): array
    {
        $filename = $this->sanitizeName($serverName) . '.conf';
        $enabledPath = $this->sitesEnabledDir . '/' . $filename;
        $disabledPath = $this->sitesDisabledDir . '/' . $filename;

        if (file_exists($enabledPath)) {
            if (!@rename($enabledPath, $disabledPath)) {
                throw new RuntimeException('Unable to disable site. Permission denied?');
            }
            $this->testConfig();
            return $this->parseSiteConfig($disabledPath, false);
        }

        if (file_exists($disabledPath)) {
            if (!@rename($disabledPath, $enabledPath)) {
                throw new RuntimeException('Unable to enable site. Permission denied?');
            }
            $this->testConfig();
            return $this->parseSiteConfig($enabledPath, true);
        }

        throw new RuntimeException('Configuration not found for ' . $serverName);
    }

    public function deleteSite(string $serverName): void
    {
        $filename = $this->sanitizeName($serverName) . '.conf';
        $paths = [
            $this->sitesEnabledDir . '/' . $filename,
            $this->sitesDisabledDir . '/' . $filename,
        ];

        $deleted = false;
        foreach ($paths as $path) {
            if (file_exists($path)) {
                if (!@unlink($path)) {
                    throw new RuntimeException('Unable to delete configuration: ' . $path);
                }
                $deleted = true;
            }
        }

        if (!$deleted) {
            throw new RuntimeException('Configuration not found for ' . $serverName);
        }

        $this->testConfig();
    }

    public function reload(): array
    {
        return $this->commandRunner->run('sudo systemctl reload nginx');
    }

    public function testConfig(): void
    {
        $testCommand = $this->allowedCommands['nginx_test'] ?? ('sudo ' . escapeshellcmd($this->nginxBinary) . ' -t');
        $result = $this->commandRunner->run($testCommand);
        if ($result['exit_code'] !== 0) {
            throw new RuntimeException('Nginx config test failed: ' . $result['stderr']);
        }
    }

    private function writeConfig(string $path, array $data): void
    {
        $template = $this->renderTemplate($data);
        if (file_put_contents($path, $template) === false) {
            throw new RuntimeException('Unable to write configuration file: ' . $path);
        }
    }

    private function renderTemplate(array $data): string
    {
        $fromSource = $this->renderFromSourceTemplate($data);
        if ($fromSource !== null) {
            return $fromSource;
        }

        $templatePath = $this->templatePath;
        if (!is_file($templatePath)) {
            throw new RuntimeException('Template not found: ' . $templatePath);
        }
        ob_start();
        $safeData = [
            'server_name' => $data['server_name'],
            'server_names' => $data['server_names'] ?? [$data['server_name']],
            'aliases' => $data['aliases'] ?? [],
            'root' => $data['root'],
            'listen_directives' => $data['listen_directives'] ?? [],
            'http_listen' => $data['http_listen'] ?? [],
            'https_listen' => $data['https_listen'] ?? [],
            'redirect_http' => $data['redirect_http'] ?? false,
            'index' => $data['index'] ?? [],
            'https' => $data['https'] ?? false,
            
            // SSL settings
            'ssl_certificate' => $data['ssl_certificate'] ?? null,
            'ssl_certificate_key' => $data['ssl_certificate_key'] ?? null,
            'ssl_protocols' => $data['ssl_protocols'] ?? 'TLSv1.2 TLSv1.3',
            'ssl_ciphers' => $data['ssl_ciphers'] ?? null,
            'ssl_prefer_server_ciphers' => $data['ssl_prefer_server_ciphers'] ?? true,
            'ssl_extra_includes' => $data['ssl_extra_includes'] ?? [],
            
            // PHP settings
            'php_enabled' => $data['php_enabled'] ?? true,
            'php_socket' => $data['php_socket'] ?? 'unix:/run/php/php8.3-fpm.sock',
            'php_index' => $data['php_index'] ?? 'index.php',
            'php_read_timeout' => $data['php_read_timeout'] ?? '60',
            
            // Logging settings
            'access_log' => $data['access_log'] ?? null,
            'error_log' => $data['error_log'] ?? null,
            'log_format' => $data['log_format'] ?? 'combined',
            'error_log_level' => $data['error_log_level'] ?? 'error',
            
            // Performance settings
            'client_max_body_size' => $data['client_max_body_size'] ?? '1M',
            'client_body_buffer_size' => $data['client_body_buffer_size'] ?? '128k',
            'fastcgi_cache_enabled' => $data['fastcgi_cache_enabled'] ?? false,
            'fastcgi_cache_path' => $data['fastcgi_cache_path'] ?? '/var/cache/nginx/fastcgi',
            'fastcgi_cache_valid' => $data['fastcgi_cache_valid'] ?? '60m',
            'fastcgi_cache_key' => $data['fastcgi_cache_key'] ?? '$scheme$request_method$host$request_uri',
            'fastcgi_cache_bypass' => $data['fastcgi_cache_bypass'] ?? '$cookie_PHPSESSID $http_authorization',
            'fastcgi_no_cache' => $data['fastcgi_no_cache'] ?? '$cookie_PHPSESSID $http_authorization',
            'fastcgi_cache_use_stale' => $data['fastcgi_cache_use_stale'] ?? false,
            'browser_cache_enabled' => $data['browser_cache_enabled'] ?? false,
            'cache_css_js' => $data['cache_css_js'] ?? '30d',
            'cache_images' => $data['cache_images'] ?? '90d',
            'cache_fonts' => $data['cache_fonts'] ?? '1y',
            'cache_media' => $data['cache_media'] ?? '1y',
            'gzip_enabled' => $data['gzip_enabled'] ?? false,
            'gzip_types' => $data['gzip_types'] ?? 'text/plain text/css application/json application/javascript text/xml application/xml',
            'gzip_comp_level' => $data['gzip_comp_level'] ?? '6',
            'gzip_min_length' => $data['gzip_min_length'] ?? '256',
            
            // Security settings
            'server_tokens' => $data['server_tokens'] ?? false,
            'x_frame_options' => $data['x_frame_options'] ?? 'SAMEORIGIN',
            'x_content_type_options' => $data['x_content_type_options'] ?? true,
            'x_xss_protection' => $data['x_xss_protection'] ?? true,
            'referrer_policy' => $data['referrer_policy'] ?? 'strict-origin-when-cross-origin',
            
            // Advanced settings
            'custom_locations' => $data['custom_locations'] ?? [],
            'custom_directives' => $data['custom_directives'] ?? '',
        ];
        $data = $safeData;
        include $templatePath;
        return trim((string) ob_get_clean()) . PHP_EOL;
    }

    private function renderFromSourceTemplate(array $data): ?string
    {
        // Only use source template if explicitly configured
        if (!$this->templateSourcePath) {
            return null;
        }

        $source = $this->templateSourcePath;

        if (!$source || !is_file($source)) {
            return null;
        }

        $template = file_get_contents($source);
        if ($template === false) {
            return null;
        }

        $serverNames = implode(' ', $data['server_names'] ?? [$data['server_name']]);
        $template = preg_replace('/server_name\s+[^;]+;/i', '    server_name ' . $serverNames . ';', $template, 1) ?? $template;

        // Remove existing listen directives and inject our own
        $template = preg_replace('/^\s*listen\s+[^;]+;\s*$/mi', '', $template) ?? $template;
        $listenLines = '';
        foreach ($data['listen_directives'] ?? [] as $directive) {
            $listenLines .= '    listen ' . $directive . ';' . PHP_EOL;
        }
        if ($listenLines !== '') {
            $template = preg_replace('/(server\s*\{)/i', '$1' . PHP_EOL . $listenLines, $template, 1) ?? $template;
        }

        $template = preg_replace('/root\s+[^;]+;/i', '    root ' . $data['root'] . ';', $template, 1) ?? $template;

        if (!empty($data['index'])) {
            $template = preg_replace('/index\s+[^;]+;/i', '    index ' . implode(' ', (array) $data['index']) . ';', $template, 1) ?? $template;
        }

        if (!empty($data['php_socket'])) {
            $template = preg_replace('/fastcgi_pass\s+[^;]+;/i', '        fastcgi_pass ' . $data['php_socket'] . ';', $template, 1) ?? $template;
        }

        if (!empty($data['https']) && !empty($data['ssl_certificate']) && !empty($data['ssl_certificate_key'])) {
            $sslCertLine = '    ssl_certificate ' . $data['ssl_certificate'] . ';';
            $sslKeyLine = '    ssl_certificate_key ' . $data['ssl_certificate_key'] . ';';
            if (preg_match('/ssl_certificate\s+[^;]+;/i', $template)) {
                $template = preg_replace('/ssl_certificate\s+[^;]+;/i', $sslCertLine, $template, 1) ?? $template;
            } else {
                $template = preg_replace('/(server\s*\{)/i', '$1' . PHP_EOL . $sslCertLine, $template, 1) ?? $template;
            }
            if (preg_match('/ssl_certificate_key\s+[^;]+;/i', $template)) {
                $template = preg_replace('/ssl_certificate_key\s+[^;]+;/i', $sslKeyLine, $template, 1) ?? $template;
            } else {
                $template = preg_replace('/ssl_certificate\s+[^;]+;/', '$0' . PHP_EOL . $sslKeyLine, $template, 1) ?? $template;
            }

            foreach ($data['ssl_extra_includes'] ?? [] as $include) {
                if (!str_contains($template, 'include ' . $include)) {
                    $template = preg_replace('/ssl_certificate_key\s+[^;]+;/', '$0' . PHP_EOL . '    include ' . $include . ';', $template, 1) ?? $template;
                }
            }
        } else {
            $template = preg_replace('/^\s*ssl_certificate[_key]?\s+[^;]+;\s*$/mi', '', $template) ?? $template;
        }

        if (!str_contains($template, 'Managed by webadmin')) {
            $template = "# Managed by webadmin panel\n" . ltrim($template);
        }

        return trim(preg_replace('/\n{3,}/', PHP_EOL . PHP_EOL, $template) ?: $template) . PHP_EOL;
    }

    private function guessTemplateSource(): ?string
    {
        foreach ([$this->sitesEnabledDir, $this->sitesDisabledDir] as $directory) {
            if (!is_dir($directory)) {
                continue;
            }

            foreach (new DirectoryIterator($directory) as $fileInfo) {
                if ($fileInfo->isDot()) {
                    continue;
                }

                if ($fileInfo->isFile() || $fileInfo->isLink()) {
                    return $fileInfo->getPathname();
                }
            }
        }

        return null;
    }

    private function resolveDefaults(array $defaults): array
    {
        $base = [
            'document_root_pattern' => $this->websitesRoot . '/{server_name}',
            'include_www_alias' => true,
            'php_fastcgi' => 'unix:/run/php/php-fpm.sock',
            'index_files' => ['index.php', 'index.html', 'index.htm'],
            'http_listen' => ['80'],
            'https_listen' => ['443 ssl http2'],
            'redirect_http_to_https' => true,
            'ssl_certificate_root' => '/etc/letsencrypt/live/{server_name}',
            'ssl_certificate_file' => 'fullchain.pem',
            'ssl_certificate_key_file' => 'privkey.pem',
            'ssl_extra_includes' => [],
        ];

        $merged = array_replace($base, $defaults);
        $merged['index_files'] = array_values(array_filter((array) ($merged['index_files'] ?? [])));
        $merged['http_listen'] = array_values(array_filter((array) ($merged['http_listen'] ?? [])) ?: ['80']);
        $merged['https_listen'] = array_values(array_filter((array) ($merged['https_listen'] ?? [])));
        $merged['ssl_extra_includes'] = array_values(array_filter((array) ($merged['ssl_extra_includes'] ?? [])));

        return $merged;
    }

    private function normalizeServerName(string $serverName): string
    {
        return strtolower(trim($serverName));
    }

    private function slugifyServerName(string $serverName): string
    {
        return trim(preg_replace('/[^a-z0-9.-]/', '-', strtolower($serverName)), '-');
    }

    private function applyPlaceholders(string $pattern, string $serverName, string $slug): string
    {
        return str_replace(['{server_name}', '{server_name_slug}'], [$serverName, $slug], $pattern);
    }

    private function generateAliases(string $serverName): array
    {
        if (($this->defaults['include_www_alias'] ?? true) === false) {
            return [];
        }

        if (str_starts_with($serverName, 'www.')) {
            $alias = substr($serverName, 4);
            return $alias && $alias !== $serverName ? [$alias] : [];
        }

        return ['www.' . $serverName];
    }

    private function buildBlueprint(string $serverName, bool $https): array
    {
        $slug = $this->slugifyServerName($serverName);
        $documentRootPattern = $this->defaults['document_root_pattern'] ?? ($this->websitesRoot . '/{server_name}');
        $root = $this->applyPlaceholders($documentRootPattern, $serverName, $slug);

        if (!str_starts_with($root, '/')) {
            $root = $this->websitesRoot . '/' . ltrim($root, '/');
        }

        if (str_contains($root, '..')) {
            throw new RuntimeException('Configured document root pattern resolves outside of allowed path.');
        }

        $root = preg_replace('#/{2,}#', '/', $root) ?? $root;

        $aliases = array_values(array_filter($this->generateAliases($serverName)));
        $serverNames = array_values(array_unique(array_merge([$serverName], $aliases)));

        $httpListen = array_values(array_filter(array_map('trim', $this->defaults['http_listen'] ?: ['80'])));
        if (!$httpListen) {
            $httpListen = ['80'];
        }
        $httpsListen = $https ? array_values(array_filter(array_map('trim', $this->defaults['https_listen'] ?: ['443 ssl']))) : [];
        $listenDirectives = $https ? array_merge($httpListen, $httpsListen) : $httpListen;
        $listenDirectives = array_values(array_unique($listenDirectives));

        $sslCertificate = null;
        $sslCertificateKey = null;
        $sslIncludes = [];
        if ($https) {
            $sslRootPattern = $this->defaults['ssl_certificate_root'] ?? '/etc/letsencrypt/live/{server_name}';
            $sslRoot = rtrim($this->applyPlaceholders($sslRootPattern, $serverName, $slug), '/');
            $sslCertificate = $sslRoot . '/' . ($this->defaults['ssl_certificate_file'] ?? 'fullchain.pem');
            $sslCertificateKey = $sslRoot . '/' . ($this->defaults['ssl_certificate_key_file'] ?? 'privkey.pem');
            $sslIncludes = array_values(array_filter(array_map('trim', $this->defaults['ssl_extra_includes'] ?? [])));
        }

        return [
            'server_name' => $serverName,
            'server_names' => $serverNames,
            'aliases' => $aliases,
            'root' => $root,
            'listen' => $listenDirectives[0] ?? '80',
            'listen_directives' => $listenDirectives,
            'http_listen' => $httpListen,
            'https_listen' => $httpsListen,
            'redirect_http' => $https && (bool) ($this->defaults['redirect_http_to_https'] ?? false),
            'php_socket' => $this->defaults['php_fastcgi'],
            'index' => $this->defaults['index_files'],
            'https' => $https,
            'ssl_certificate' => $sslCertificate,
            'ssl_certificate_key' => $sslCertificateKey,
            'ssl_extra_includes' => $sslIncludes,
        ];
    }

    private function ensureSiteRoot(string $root): void
    {
        if (!is_dir($root)) {
            if (!@mkdir($root, 0755, true)) {
                throw new RuntimeException('Unable to create site root directory: ' . $root);
            }
        }
        
        // Create logs directory for site-specific logging
        $logsDir = $root . '/logs';
        if (!is_dir($logsDir)) {
            if (!@mkdir($logsDir, 0755, true)) {
                throw new RuntimeException('Unable to create logs directory: ' . $logsDir);
            }
        }
        
        // Create common log files if they don't exist
        $logFiles = [
            $logsDir . '/access.log',
            $logsDir . '/error.log'
        ];
        
        foreach ($logFiles as $logFile) {
            if (!file_exists($logFile)) {
                if (@touch($logFile)) {
                    @chmod($logFile, 0644);
                } else {
                    // Don't throw error if we can't create log files, they'll be created by nginx
                    error_log("Warning: Could not create log file: $logFile");
                }
            }
        }
    }

    private function validateRoot(string $root): void
    {
        $normalizedRoot = rtrim($root, '/');
        $allowedRoot = realpath($this->websitesRoot) ?: $this->websitesRoot;
        $rootDir = dirname($normalizedRoot);
        if (!str_starts_with($normalizedRoot, $allowedRoot)) {
            throw new RuntimeException('Root path must be within ' . $this->websitesRoot);
        }
        if (!is_dir($rootDir) && !@mkdir($rootDir, 0755, true)) {
            throw new RuntimeException('Unable to create parent directory: ' . $rootDir);
        }
    }

    public function updateSiteConfig(string $serverName, array $configData): void
    {
        $filename = $this->sanitizeName($serverName) . '.conf';
        $enabledPath = $this->sitesEnabledDir . '/' . $filename;
        $disabledPath = $this->sitesDisabledDir . '/' . $filename;
        
        // Determine which path to use
        $configPath = file_exists($enabledPath) ? $enabledPath : $disabledPath;
        
        if (!file_exists($configPath)) {
            throw new RuntimeException('Configuration file not found for ' . $serverName);
        }
        
        $this->writeConfig($configPath, $configData);
        $this->testConfig();
    }

    private function sanitizeName(string $name): string
    {
        return preg_replace('/[^a-zA-Z0-9.-]/', '_', strtolower($name));
    }
}
